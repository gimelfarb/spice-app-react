import debug from './debug';
import { VNodeState } from './vnode';

/**
 * Recursively blends the generated React (v)DOM tree with the
 * real existing DOM, by locating and matching nodes to merge.
 * 
 * @param {Element} domRoot 
 * @param {import('./vnode').VNode} vtree 
 */
export function attachToDOM(domRoot, vtree) {
    // Use a stack array for recursive traversal
    const stack = [{ domCtx: domRoot, vnode: vtree }];

    while (stack.length) {
        // domCtx - context parent for searching matching node
        // vnode - (v)DOM tree node to merge
        const { domCtx, vnode } = stack.shift();
        if (vnode.state !== VNodeState.PENDING) {
            debug.log(`WARNING: Tried to attach non-pending vnode (state = ${vnode.state})`);
            continue;
        }

        // Try to locate an existing node
        const selector = makeSelector(vnode.domNode);
        let domNode = domCtx.querySelector(selector);
        if (!domNode) {
            // If cannot find, then just insert the new DOM node
            // that was generated by React
            debug.log(`Not found: ${selector}`, domCtx);
            domNode = domCtx.appendChild(vnode.domNode);
            vnode.targetSelf();
        } else {
            // Found matching node, so we'll perform a merge
            debug.log(`Attaching to existing: ${selector}`);
            vnode.attach(domNode);

            // Add children to the stack array to process recursively
            if (vnode.children && vnode.children.length) {
                const child_frames = vnode.children.map(c => ({ domCtx: domNode, vnode: c }));
                stack.push(...child_frames);
            }
        }
    }
}

/**
 * 
 * @param {import('./vnode').VNode} vtree 
 */
export function detachFromDOM(vtree) {
    const stack = [{ vnode: vtree }];
    while (stack.length) {
        const { vnode } = stack.shift();
        if (vnode.state === VNodeState.DIRECT) {
            debug.log(`Detach - removing: <${vnode.domNode.tagName}>`);
            vnode.domNode.parentNode.removeChild(vnode.domNode);
        } else if (vnode.state === VNodeState.ATTACHED) {
            debug.log(`Detach - restoring: <${vnode.domNode.tagName}>`);
            vnode.restore && vnode.restore();

            if (vnode.children && vnode.children.length) {
                const child_frames = vnode.children.map(c => ({ vnode: c }));
                stack.push(...child_frames);
            }
        }

        vnode.detach();
    }
}

/**
 * Selector for locating existing DOM elements to merge with.
 * 
 * @param {Element} domNode 
 * @returns {string}
 */
function makeSelector(domNode) {
    // If we have an id attribute, then it trumps all others
    if (domNode.id && typeof domNode.id === 'string') {
        return `${domNode.tagName}#${domNode.id}`;
    // Alternatively, we can have a name attribute, which is 2nd best
    } else if (domNode.name && typeof domNode.name === 'string') {
        return `${domNode.tagName}[name="${domNode.name}"]`;
    } else {
        switch (domNode.tagName.toLowerCase()) {
            case 'button':
                // We might match a button by 'type' attribute, but it only
                // works if there are not multiple buttons of same type
                if (domNode.type) {
                    return `${domNode.tagName}[type="${domNode.type}"]`;
                }
                break;
            case 'label':
                // We can match a <label /> by the 'for' attribute
                if (domNode.htmlFor) {
                    return `${domNode.tagName}[for="${domNode.htmlFor}"]`;
                }
                break;
        }
    }
    // Default is to just match by tag name, which would find the first
    // child of the same type
    return domNode.tagName;
}
